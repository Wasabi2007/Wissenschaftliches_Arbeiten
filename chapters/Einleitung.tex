\chapter{Einleitung}
%Begonnen werden soll mit einer Einleitung zum Thema: z.B. Hintergrund und Ziel
%(was, warum).
In vielen Computerspielen ist eine Funktion von Nöten um Einheiten und Charaktere ans Ziel zu führen. Egal in welchen Genre, wenn sich der Computer in einer simulierten Umgebung effizient zurecht finden soll, wird ein Wegfindealgorithmus benötigt. Um Umwege und unnatürlich wirkendes Verhalten zu vermeiden, bietet sich ein heuristischer, Graphen basierter Algorithmus an.
Dieser hat sich als effizienteste Lösung für Wegfindeprobleme erwiesen.\\
Nicht nur in Civilization, wo die Funktionsweise dem Spieler als ein Zentrales Spielelement bewusst wird, finden solche Algorithmen Verwendung. Auch Genres scheinbar abseits taktischer Tiefe, wie Beispielsweise MMORPGS oder Shootern wären ohne dieselben nicht realisierbar.\\

%In vielen Jahren der Spieleentwicklung hat sich A*(A-Stern) als der Effizienteste seiner Art herauskristallisiert.
Wegen seiner einfachen Implementierung und seines hohen Effizienzgrades hat sich A*(A-Stern) als Geeignetster seiner Art bewährt. Daher wird heute kaum noch auf andere Lösungen zurückgegriffen um entsprechende Probleme zu bewältigen. In so fern wird sich diese Arbeit mit den Eigenschaften und der Umsetzung in Programmen von A* befassen.

\chapter {Dijkstra}
Dijkstra bildet die Grundlage zu A*. Er wurde vom gleichnamigen Professor im Jahr 1959 in einem Lehrbuch erläutert.\footnote{\cite{EWD:NumerMath59}} Es ist der üblichste Algorithmus, der für Netzwerkrouting eingesetzt wird.\footnote{\cite{tanenbaum:CN}} \\

\section {Funktionsweise}
Die Knoten im Dijkstra-Algorithmus haben folgende Eigenschaften:
\begin{itemize}
	\item Die Kosten des ersten Knotens betragen 0.
	\item Sonstige Knotenkosten akkumulieren sich aus den Kosten der Vorgängerknoten.
	\item Die Unbekannten ausgenommen, hat jeder Knoten ein Vorgänger, der die bisher kürzeste Verbindung zum ersten Knoten darstellt.
	\item fertig untersuchte Knoten werden ignoriert
\end{itemize}

 Die allgemeine iterative Vorgehensweise läuft folgendermaßen ab:
\begin{enumerate}
	\item Die Knoten werden in 3 Listen sortiert
	\begin{itemize}
		\item unbekannte Knoten
		\item zu untersuchende Knoten
		\item fertig untersuchte Knoten
	\end{itemize}
	\item Am Anfang ist der Startknoten als "'zu untersuchend"' markiert, alle Anderen sind unbekannt. \ref{Schritt 0}
	\item Aus der Liste der zu untersuchenden Knoten wird nun jener erwählt, welcher am wenigsten Kosten verursacht. \item Dieser wird nun in die Liste der fertig untersuchten Knoten verschoben. \ref{Schritt 7}
	\begin{itemize}
		\item War dies der Zielknoten, so ergibt sich als Ergebnis der Weg vom Anfang bis zum Ziel. \ref{Schritt 25}
		\item Wenn nicht, so werden die unbekannten, direkt verbundenen Knoten in die Liste der zu Untersuchenden angefügt. Dabei werden die Kosten der Knoten ermittelt und der Vorgängerknoten gesetzt.(\ref{Schritt 1} - \ref{Schritt 6})\\ 
		Es gilt:\\
		$Knotenkosten=Weg+Kante$\\
		$D(k_{i})=D(k_{i-1})+Kantenkosten$
		\\
		Falls für den Knoten schon einmal Kosten ermittelt wurden, so wird der niedrigste Betrag übernommen.
	\end{itemize}
\end{enumerate}
Schritte 3 und 4 werden wiederholt bis die Liste der zu Untersuchenden Knoten leer ist. Bei einem erfolgreichen Ablauf, kann vom Ziel bis zum Startknoten der kürzeste Weg verfolgt werden.(\ref{Schritt 1} - \ref{Schritt 25})\\
Falls das Ziel nicht erreicht wurde, gibt es keinen Weg über die angegebenen Knoten.\\

\subsection{Ein kleines Beispiel}

\newcounter{Schritt}
\setcounter{Schritt}{0}

\begin{figure}
\centering
\caption{Schritt 0 - 11}
\label{Schritt 0 - 11}
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\end{figure}
\begin{figure}
\caption{Schritt 12 - 26}
\label{Schritt 12 - 26}
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.24\textwidth} %[hbtp]
\centering
		\includegraphics[width=\textwidth]{images/Dijkstra-Beispiel/\arabic{Schritt}.png}
	\caption{Schritt \arabic{Schritt}}
	\label{Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\end{figure}


\chapter{A*}
Der Algorithmus von Dijkstra stellte sich als zufriedenstellend für den Netzwerkverkehr heraus. Aber für die Anforderungen, die KI-Entwickler ende der Sechziger Jahre zu bewältigen hatten war er einfach nicht geeignet. Dijkstra ist klar im Vorteil wenn eine Strecke über bekannte Punkte mit konstanten Längen zurück gelegt werden soll. Aber sobald es möglich ist die Kosten vom aktuelle Knoten zum Ziel zu schätzen, kann die Wegfindung optimiert werden.
A* ist demnach kein komplett neues Verfahren, sondern nur eine Optimierung des ursprünglichen Algorithmus hinsichtlich dieser Punkte. Das wird besonders deutlich, wenn A* gegen eine Wand läuft. Hier gleicht sich der Schätzwert, für neue Knoten, welche vermeidlich nahe am Ziel sind mit den ehemals höheren Kosten der Knoten am Startpunkt an. So wird, je nach Implementierung, ein Feld nach dem anderen abgeklappert bis der Pfad nicht mehr blockiert ist.
Eine Besonderheit von A* ist, dass er optimal effizient eine Lösung findet - diese ist gleichzeitig der günstigste Weg. Er ist, unter den selben Ausgangsbedingungen (Heuristik), in seiner Geschwindigkeit kombiniert mit jener Genauigkeit nicht mehr zu übertrumpfen.\footnote{ http://de.wikipedia.org/w/index.php?title=A*-Algorithmus\&oldid=129862855}\\
Dazu kommt, dass die Heuristik dahingehend modifizierbar ist, A* schneller zum Ziel finden zu lassen. Dieser Weg wird voraussichtlich nicht der optimale sein. So wird Rechenzeit auf Kosten der Genauigkeit gewonnen.

\section{Funktionsweise}
Vor jedem Schritt werden die anliegenden Knoten überprüft. Der Computer berechnet zu erst, wie bei Dijkstra, die bisher zurück gelegten Kosten. Zusätzlich kommt nun hinzu, dass die Punkte noch einen Schätzwert erhalten, wie weit sie vom Ziel entfernt sind.\\
Zur Formel kommt dies nun als der Faktor $h(k)$.\\
Es gilt nun:\\
$F(k)=D(k)+h(k)$

\section{Beispiel}

\setcounter{Schritt}{1}

\begin{figure}
\centering
\caption{Schritt 0 - 6}
\label{Schritt 0 - 6}
\begin{subfigure}[b]{0.49\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/A-Stern-Beispiel/aStar(\arabic{Schritt}).jpg}
	\caption{Schritt \arabic{Schritt}}
	\label{A-Stern-Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.49\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/A-Stern-Beispiel/aStar(\arabic{Schritt}).jpg}
	\caption{Schritt \arabic{Schritt}}
	\label{A-Stern-Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.49\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/A-Stern-Beispiel/aStar(\arabic{Schritt}).jpg}
	\caption{Schritt \arabic{Schritt}}
	\label{A-Stern-Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\hfill
\begin{subfigure}[b]{0.49\textwidth} %[hbtp]
		\includegraphics[width=\textwidth]{images/A-Stern-Beispiel/aStar(\arabic{Schritt}).jpg}
	\caption{Schritt \arabic{Schritt}}
	\label{A-Stern-Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\\
\begin{subfigure}[b]{0.49\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/A-Stern-Beispiel/aStar(\arabic{Schritt}).jpg}
	\caption{Schritt \arabic{Schritt}}
	\label{A-Stern-Schritt \arabic{Schritt}}
	\addtocounter{Schritt}{1}
\end{subfigure}
\end{figure}


 
\chapter{Vergleich der beiden Algorithmen}
\begin{table}
%Algorithmus & Worst Case & Best Case &    hoi\\
%Dijkstra & blabla & Honigkuchen &    oi\\
% A*	&	&	& ahoi \\
\end{table}
\begin{table} %[hbtp]
	%\centering
	\large
		\begin{tabular}{|c| c|c| c| c|}
		\hline
		\textbf{Algorithmen} & \textbf{Worst Case Laufzeit} & \textbf{Best Case Laufzeit} \\
		\hline
		Djikstra & $O(|V|^2)$ & $O(1)$   \\
		\hline
		A* & $O(|V|^2)$ & $O(1)$  \\
		\hline
		\end{tabular}
	\caption{Bezeichnung der Tabelle}
	\label{t1}
\end{table}

\begin{figure}
\centering
\label{DvsA}
\caption{Dikstra Vergleich A*}
\begin{subfigure}[b]{0.15\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/progress_Path_animation_firstframe.png}
	\label{Frame1}
	\caption{Ausganssituation}
\end{subfigure}
\\
\begin{subfigure}[b]{0.15\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/progress_Dijkstras_animation_lastframe.png}
	\label{lastFrameD}
	\caption{Endsituation Dijkstra}
\end{subfigure}
\begin{subfigure}[b]{0.15\textwidth} %[hbtp]
	\centering
		\includegraphics[width=\textwidth]{images/progress_Astar_animation_lastframe.png}
	\label{lastFrameA}
	\caption{Endsituation A*}
\end{subfigure}
\end{figure}

\chapter{Implementierung in Computerspielen}
In der Praxis werden in heutigen Spielen Mobs nicht mehr einfach über eine 2-Dimensionale Oberfläche, mit n Knoten, ans Ziel gelotst. In 3D Spielen ist nicht nur die Frage wie optimal, sondern auch wie natürlich sich die Figur zum Zielpunkt bewegt.
%In der dritten Dimension müssen, sich scheinbar überlappende Wege, (z.B. unterschiedliche Stockwerke) auf eine zweidimensionale Ebene herunter gebrochen werden.\\
\section{Drahtgitter}
Ein Drahtgitter (oder auch Grid) ist wie das Blatt eines Rechenblockes, welches über eine Karte gelegt wird. Diese Technik findet heute noch bei Strategietiteln Verwendung und war in den Neunzigern quasi Standard für alle Spiele aus der Vogelperspektive.
Den Feldern können Eigenschaften zugewiesen werden. So kann man bestimmen ob sich die Figur vor, hinter oder gar nicht über ein Objekt bewegen kann.\\
Je nach Bedarf können so auch Felder mit höheren oder niedrigeren Bewegungskosten, Schaden oder Heilung und anderen Boni und Mali versehen werden.

\section{Navigation Meshes}
Hier handelt es sich um Polygone, welche bei Erstellung der Karte auf den Boden gelegt werden um die begehbare Zone auszuweisen. Gewissermaßen werden aus den Verbindungslinien der Knoten -bei Dijkstra- breite Straßen. So wird der ehemalige Seiltänzer, der sich auf einer festen Linie von A nach B bewegt ein Fahrradfahrer mit Spielraum auf der Strecke.\\
Zusätzlich kommt hinzu, dass jedes Dreieck der Polygone als Knoten verwertet werden kann. Dies wird generell nur ausgenutzt, wenn sich neue Ruten erschließen und neue Wegfinde-Entscheidungen zu treffen sind. Daraus erschließt sich auch die Dynamik dieser Felder.\\
Es muss beachtet werden, diesen Meshes eine weitere Dimension zu verpassen, soll sich der Mob komplett in den Raum bewegen. Also für den Fall er taucht oder fliegt.

\begin{figure}
	\centering
		\includegraphics[width=0.5\textwidth]{images/Navmeshes-2.png}
	\label{navmesh}
	\caption{Navmesh Beispiel aus Unity3D}
\end{figure}

\subsection{Off-Mesh-Links}
In einigen Fällen werden im Level-Design Schluchten oder Klippen eingesetzt um Bereiche von einander zu trennen. Sei es aus ästhetischen- oder gameplay- relevanten Gründen. Damit die KI auch diese Lücken überwinden kann, werden Off-Mesh-Links eingesetzt, die Geometrisch von einander Getrennte Navmeshes mit einander verbindet. %(siehe Abb. \ref{OffMeshesLinks})
\begin{figure}
	\centering
		\includegraphics[width=0.5\textwidth]{images/OffMeshLinks-1.png}
	\caption{Off-Meshes links Beispiel aus Unity3D}
	\label{OffMeshesLinks}
\end{figure}

\subsection{Bewegung in Meshes}
Auf den Mesh-Polygonen können sich die Figuren in unterschiedlicher Weise orientieren. Es kommt darauf an, für die Situation geeignete Knoten auf den Polygonen zu setzen.
\begin{itemize}
\item Polygon movement\\
Die Knoten sitzen im Mittelpunkt der Dreiecke.\\
Diese Form hat die wenigsten Punkte, bieten dennoch ein natürliches Bewegungsmuster, ohne die CPU zu arg zu belasten.
\item  Edge movement\\
Die Knoten sitzen auf den Kanten, die an andere Dreiecke schließen\\
Meist ist es unnötig durch den Mittelpunkt aller Polygone zu gehen. Dieser Weg braucht mehr CPU, sieht dafür noch etwas realistischer aus.
\item Vertex movement\\
Die Knoten sitzen auf allen Eckpunkten\\
Der schnellste Weg geht meist direkt an einem Objekt vorbei. Mit dieser Mesh-Anordnung nimmt die Figur auch auf jeden Fall diese Route. Aber "'Wandschmußer"' hinterlassen nicht gerade das Bild eines realistischen Spielers.
\item Hybrid movement\\
Kombinationen der Oberen\\
Dies wird wohl die natürlichste Form der Spielerbewegung wiedergeben. Aber dafür gibt es auch immer eine größere Menge an Knoten zu berechnen, als wenn nur eine andere Form implementiert wird.
\end{itemize}

\subsection{Pfadglättung}
Egal welche Art von Mesh-Anordnung verwendet wird. Solange die Fortbewegungskosten konstant bleiben, kann man den Weg gerader machen.\\
So simuliert man zwar nicht NPC Verhalten in einer simulierten Welt, jedoch beispielsweise menschliches Gebaren für simulierte Gegner in Multiplayerspielen.
Ein Mensch würde, wenn er von A nach B kommen wollte, auf B zielen und nur den "'nach-vorne-Laufen"' Knopf betätigen. Es wäre ihm egal ob er an der Wand entlang schrammt oder sich dabei sonst wie nicht natürlich verhält.\\
Der benutzte Algorithmus ist dabei denkbar simpel.\\
Wenn man an Punkt $i$ steht und $i+2$ sichtbar ist, wird $i+1$ gelöscht. Wird dies oft genug wiederholt, besteht der Weg nur noch aus geraden Pfaden und den nötigen Eckpunkten.


\section{Spielererfahrung}

Auf keinen Fall sollte es sich für den Spieler so anfühlen, als würde der Computer cheaten, um zu gewinnen. Es lässt sich durch die Mechanik der Programmierung jedoch fast nie vermeiden, dem KI-Gegner einen Vorsprung in Sachen taktischer Informationen zu gewähren. Daher Computer generell nicht "'Betrügen"', im Sinne des Wortes, können, kommt es letztendlich nur darauf an, was der Spieler vom Verhalten des Gegners mit bekommt.  \\
Eine gute Methode ist Beispielsweise, in einem Spiel die generellen Geländekosten für Felder zu erhöhen, die noch unerforscht sind. Obwohl dies für die KI offenkundig nie der Fall sein wird. So werden die gegnerischen Einheiten bevorzugt über aufgedecktes Gelände geschickt.
Natürlich sollte dieses Prinzip nicht für Einheiten gelten, welche erforschen sollen.\\
Am Ende soll es darauf hinaus laufen, dass der Gegner seine Einheiten wie ein menschlicher Spieler bewegt.\\
Ebenfalls darf der Spieler nicht der Meinung sein, dass seine Einheiten nicht das tut, was er ihnen befiehlt. \\
Eine sehr gute Methode zu verschleiern, was vor sich geht, ist die Einheit erst einmal in grober Richtung des Ziels aufbrechen und die Wegfindung bei niedrigster Priorität anlaufen zu lassen.
So wird dem Benutzer automatisch mitgeteilt, dass seine Befehle angekommen sind und die Steuerung funktioniert.
http://theory.stanford.edu/~amitp/GameProgramming/UserExperience.html

\section{Performance}
Die Hauptschleife von A* ließt sich durch eine priorisierte Liste, analysiert und vertauscht dort Knoten. Ebenfalls werden die Knoten gespeichert, die schon besucht wurden.\\
Die Liste verkürzen wäre natürlich die offensichtlichste Lösung um die Prozedur zu vereinfachen. Generell gilt: Wege über Meshes sind einfacher zu berechnen als über ein Grid, weil sie in der Regel weniger Knoten haben als diese.\\
\subsection{Kartenhierarchie}
Wenn größere Strecken zurückgelegt werden sollen, nehmen die benötigten Kosten zum Berechnung schnell überhand. Eine gute Methode um dies zu vermeiden ist, eine vereinfachte, hierarchische Kartendarstellung zu erzeugen.\\
Generell kann man sich dieses Bewegungsmuster quasi so vorstellen, dass es auf größeren Welten etwas wie Bahnlinien gibt, an die sich die Figur halten kann. Kurz vor dem Ziel wird dieser Pfad verlassen und mit höherer Auflösung nach dem besten Weg gesucht.
Zum Beispiel lassen sich in vielen Spielen Häuser betreten und durch mehrere Zimmer beschreiten. Sitzt die Figur in einem Auto mit 120km/h auf der Autobahn, wird dies wohl nicht so schnell passieren.\\
Die Hierarchie muss ebenfalls nicht Homogen verlaufen. So kann man Grids und Meshes je nach Bedarf verwenden, vergrößern oder vereinfachen.
Ist die Welt auf dem hierarchisch obersten Layer, kann an bestimmten unveränderlichen Punkten, der einfachste Weg durch das Tile oder den Mesh bereits errechnet sein. Alle Wege, die eine gewisse Komplexität unterschreiten, sind so in der höchsten Auflösung bereits ermittelt.\\
http://theory.stanford.edu/~amitp/GameProgramming/MapRepresentations.html
